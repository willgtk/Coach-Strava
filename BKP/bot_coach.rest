import os
import requests
import json
from datetime import datetime, timedelta
from dotenv import load_dotenv, set_key
import telebot
from stravalib.client import Client
import schedule
import time
import threading 

# ==========================================
# 1. CARREGAR VARI√ÅVEIS
# ==========================================
env_path = os.path.join(os.path.dirname(__file__), '.env')
load_dotenv(env_path)

STRAVA_CLIENT_ID = os.getenv('STRAVA_CLIENT_ID')
STRAVA_CLIENT_SECRET = os.getenv('STRAVA_CLIENT_SECRET')
STRAVA_TOKEN = os.getenv('STRAVA_TOKEN')
STRAVA_REFRESH_TOKEN = os.getenv('STRAVA_REFRESH_TOKEN')
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
OPENWEATHER_API_KEY = os.getenv('OPENWEATHER_API_KEY')

# Inicializa Telegram e Strava
bot = telebot.TeleBot(TELEGRAM_TOKEN)
client_strava = Client(access_token=STRAVA_TOKEN)

# Mem√≥ria manual para o chat REST
historico_chat = []

instrucoes_coach = """
√âs um parceiro e treinador de Mountain Bike focado em condicionamento e qualidade de vida. 
O teu aluno pedala uma Oggi Agile Sport (SRAM GX) em Curitiba e faz parte da Equipe Partiu Pedal.
Ele n√£o treina para competi√ß√µes, o objetivo dele √© construir base aer√≥bica ("ter motor").
Analisa os dados do Strava, clima e desgaste. Sugere treinos, s√™ conciso e motivador.
"""

# ==========================================
# 2. BYPASS DA BIBLIOTECA GOOGLE (API REST)
# ==========================================
def falar_com_gemini(mensagem_usuario):
    global historico_chat
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={GOOGLE_API_KEY}"
    
    # Adiciona a mensagem atual ao hist√≥rico
    historico_chat.append({"role": "user", "parts": [{"text": mensagem_usuario}]})
    
    payload = {
        "system_instruction": {
            "parts": [{"text": instrucoes_coach}]
        },
        "contents": historico_chat
    }
    
    try:
        response = requests.post(url, headers={'Content-Type': 'application/json'}, data=json.dumps(payload))
        dados = response.json()
        
        if response.status_code == 200:
            resposta_texto = dados['candidates'][0]['content']['parts'][0]['text']
            # Salva a resposta do bot na mem√≥ria para manter o contexto
            historico_chat.append({"role": "model", "parts": [{"text": resposta_texto}]})
            return resposta_texto
        else:
            # Se der erro 429, ele limpa o hist√≥rico para tentar salvar a pr√≥xima requisi√ß√£o
            if response.status_code == 429:
                historico_chat = []
            return f"Erro na IA do Google (C√≥digo {response.status_code}): {dados.get('error', {}).get('message', 'Erro desconhecido')}"
            
    except Exception as e:
        return f"Falha ao conectar com o Google API: {e}"

# ==========================================
# 3. FUN√á√ïES STRAVA E CLIMA
# ==========================================
def renovar_token_strava():
    print("üîÑ A tentar renovar o token do Strava...")
    url = "https://www.strava.com/oauth/token"
    payload = {
        'client_id': STRAVA_CLIENT_ID,
        'client_secret': STRAVA_CLIENT_SECRET,
        'grant_type': 'refresh_token',
        'refresh_token': os.getenv('STRAVA_REFRESH_TOKEN')
    }
    response = requests.post(url, data=payload)
    if response.status_code == 200:
        dados = response.json()
        set_key(env_path, 'STRAVA_TOKEN', dados['access_token'])
        set_key(env_path, 'STRAVA_REFRESH_TOKEN', dados['refresh_token'])
        os.environ['STRAVA_TOKEN'] = dados['access_token']
        os.environ['STRAVA_REFRESH_TOKEN'] = dados['refresh_token']
        client_strava.access_token = dados['access_token']
        return True
    return False

def obter_resumo_semana():
    uma_semana_atras = datetime.now() - timedelta(days=7)
    try:
        atividades = client_strava.get_activities(after=uma_semana_atras)
        atividades_lista = list(atividades)
    except Exception as e:
        if "401" in str(e) or "unauthorized" in str(e).lower():
            if renovar_token_strava():
                atividades = client_strava.get_activities(after=uma_semana_atras)
                atividades_lista = list(atividades)
            else:
                return "Erro cr√≠tico na renova√ß√£o de token."
        else:
            return f"Erro desconhecido: {e}"

    total_km = total_elevacao = qtd_pedais = 0
    for act in atividades_lista:
        if act.type in ["Ride", "VirtualRide", "MountainBikeRide"]:
            total_km += float(act.distance) / 1000
            total_elevacao += float(act.total_elevation_gain)
            qtd_pedais += 1
            
    if qtd_pedais == 0:
        return "Nenhum pedal registado nos √∫ltimos 7 dias."
    return f"{qtd_pedais} pedais, {total_km:.1f} km rodados, {total_elevacao:.0f}m de eleva√ß√£o."

def obter_previsao_tempo():
    if not OPENWEATHER_API_KEY:
        return "Clima: API Key n√£o configurada."
    try:
        url = f"http://api.openweathermap.org/data/2.5/forecast?q=Curitiba,BR&appid={OPENWEATHER_API_KEY}&units=metric&lang=pt"
        res = requests.get(url).json()
        previsoes = res['list'][:8]
        resumo = ""
        for p in previsoes[::2]:
            resumo += f" {p['dt_txt'][11:16]}h: {p['main']['temp']:.0f}¬∞C, {p['weather'][0]['description']} |"
        return resumo
    except Exception as e:
        return f"Erro ao buscar previs√£o: {e}"

def obter_status_bike():
    try:
        athlete = client_strava.get_athlete()
        if not athlete.bikes:
            return "Nenhuma bicicleta registada no Strava."
        bike = athlete.bikes[0]
        distancia_km = float(bike.distance) / 1000
        return f"A Oggi tem {distancia_km:.1f} km acumulados no Strava."
    except Exception as e:
        return "Erro ao verificar desgaste da bicicleta."

# ==========================================
# 4. MOTOR PROATIVO (SCHEDULER)
# ==========================================
def mensagem_planeamento_fim_de_semana():
    chat_id = os.getenv('TELEGRAM_CHAT_ID')
    if not chat_id: return

    print("A analisar dados completos para mensagem proativa...")
    prompt = f"Inicia conversa proativa. Sexta-feira. Resumo Treino: {obter_resumo_semana()}. Clima: {obter_previsao_tempo()}. Bike: {obter_status_bike()}."
    
    resposta_ia = falar_com_gemini(prompt)
    bot.send_message(chat_id, resposta_ia)

def agendador_em_segundo_plano():
    while True:
        schedule.run_pending()
        time.sleep(1)

schedule.every().friday.at("18:00").do(mensagem_planeamento_fim_de_semana)
# schedule.every(1).minutes.do(mensagem_planeamento_fim_de_semana)

threading.Thread(target=agendador_em_segundo_plano, daemon=True).start()

# ==========================================
# 5. ROTAS DO TELEGRAM
# ==========================================
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    chat_id = str(message.chat.id)
    set_key(env_path, 'TELEGRAM_CHAT_ID', chat_id)
    os.environ['TELEGRAM_CHAT_ID'] = chat_id
    bot.reply_to(message, "Coach Rest-API ativado! üöµ‚Äç‚ôÇÔ∏è")

@bot.message_handler(commands=['semana'])
def analisar_semana(message):
    bot.reply_to(message, "A procurar dados de treino, clima e equipamento... ‚è≥")
    prompt = f"O atleta pediu um resumo manual. Treino: {obter_resumo_semana()}. Clima: {obter_previsao_tempo()}. Bike: {obter_status_bike()}."
    resposta_ia = falar_com_gemini(prompt)
    bot.reply_to(message, resposta_ia)

@bot.message_handler(func=lambda message: True)
def conversa_livre(message):
    bot.send_chat_action(message.chat.id, 'typing')
    resposta_ia = falar_com_gemini(message.text)
    bot.reply_to(message, resposta_ia)

print("ü§ñ Coach API Rest Puro a correr no Telegram!")
bot.infinity_polling()