import os
import requests
from datetime import datetime, timedelta
from dotenv import load_dotenv, set_key
import telebot
from google import genai
from google.genai import types
from stravalib.client import Client

# NOVO: Bibliotecas para o Motor Proativo
import schedule
import time
import threading 

# 1. Carregar as vari√°veis
env_path = os.path.join(os.path.dirname(__file__), '.env')
load_dotenv(env_path)

STRAVA_CLIENT_ID = os.getenv('STRAVA_CLIENT_ID')
STRAVA_CLIENT_SECRET = os.getenv('STRAVA_CLIENT_SECRET')
STRAVA_TOKEN = os.getenv('STRAVA_TOKEN')
STRAVA_REFRESH_TOKEN = os.getenv('STRAVA_REFRESH_TOKEN')
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')

# 2. Inicializar as APIs
bot = telebot.TeleBot(TELEGRAM_TOKEN)
client_ai = genai.Client(api_key=GOOGLE_API_KEY)
client_strava = Client(access_token=STRAVA_TOKEN)

instrucoes_coach = """
Voc√™ √© um parceiro e treinador de Mountain Bike focado em condicionamento e qualidade de vida. 
Seu aluno pedala uma Oggi Agile Sport (SRAM GX) e faz parte da Equipe Partiu Pedal e quer ser o melhor ciclista!
Ele n√£o treina para competi√ß√µes, o objetivo dele √© construir uma base aer√≥bica forte ("ter motor") para estar sempre pronto para qualquer pedal com o grupo, sem sofrer nas subidas.
Analise os dados do Strava, sugira treinos focados em const√¢ncia e resist√™ncia, e seja um motivador amig√°vel.
Sempre responda de forma concisa, direta e com bom humor, ideal para leitura no Telegram.
"""

chat_session = client_ai.chats.create(
    model='gemini-2.5-flash',
    config=types.GenerateContentConfig(system_instruction=instrucoes_coach)
)

# ==========================================
# FUN√á√ÉO DE RENOVA√á√ÉO DE TOKEN (Mantida igual)
# ==========================================
def renovar_token_strava():
    print("üîÑ A tentar renovar o token...")
    url = "https://www.strava.com/oauth/token"
    payload = {
        'client_id': STRAVA_CLIENT_ID,
        'client_secret': STRAVA_CLIENT_SECRET,
        'grant_type': 'refresh_token',
        'refresh_token': os.getenv('STRAVA_REFRESH_TOKEN')
    }
    response = requests.post(url, data=payload)
    if response.status_code == 200:
        dados = response.json()
        set_key(env_path, 'STRAVA_TOKEN', dados['access_token'])
        set_key(env_path, 'STRAVA_REFRESH_TOKEN', dados['refresh_token'])
        os.environ['STRAVA_TOKEN'] = dados['access_token']
        os.environ['STRAVA_REFRESH_TOKEN'] = dados['refresh_token']
        client_strava.access_token = dados['access_token']
        return True
    return False

def obter_resumo_semana():
    uma_semana_atras = datetime.now() - timedelta(days=7)
    try:
        atividades = client_strava.get_activities(after=uma_semana_atras)
        atividades_lista = list(atividades)
    except Exception as e:
        if "401" in str(e) or "unauthorized" in str(e).lower():
            if renovar_token_strava():
                atividades = client_strava.get_activities(after=uma_semana_atras)
                atividades_lista = list(atividades)
            else:
                return "Erro cr√≠tico na renova√ß√£o de token."
        else:
            return f"Erro desconhecido: {e}"

    total_km = 0
    total_elevacao = 0
    qtd_pedais = 0
    
    for act in atividades_lista:
        if act.type in ["Ride", "VirtualRide", "MountainBikeRide"]:
            total_km += float(act.distance) / 1000
            total_elevacao += float(act.total_elevation_gain)
            qtd_pedais += 1
            
    if qtd_pedais == 0:
        return "Nenhum pedal registado nos √∫ltimos 7 dias."
    return f"Resumo dos √∫ltimos 7 dias: {qtd_pedais} pedais, {total_km:.1f} km rodados, {total_elevacao:.0f}m de eleva√ß√£o."

# ==========================================
# üöÄ NOVO: MOTOR PROATIVO (SCHEDULER)
# ==========================================
def mensagem_planeamento_fim_de_semana():
    chat_id = os.getenv('TELEGRAM_CHAT_ID')
    if not chat_id:
        print("Aviso: O bot tentou enviar uma notifica√ß√£o, mas n√£o sabe o seu Chat ID. Envie /start no Telegram.")
        return

    print("A enviar mensagem proativa para o ciclista...")
    dados = obter_resumo_semana()
    
    # O Prompt for√ßando a IA a iniciar a conversa
    prompt = f"Inicia a conversa de forma proativa! √â sexta-feira. Analisa os dados da semana: {dados}. Sugere de forma animada um tipo de treino para o fim de semana (ex: estrad√£o longo ou trilho t√©cnico). S√™ direto."
    
    resposta_ia = chat_session.send_message(prompt)
    bot.send_message(chat_id, resposta_ia.text)

# Thread que corre em segundo plano a verificar o rel√≥gio
def agendador_em_segundo_plano():
    while True:
        schedule.run_pending()
        time.sleep(1)

# Agendamento: Sexta-feira √†s 18:00
schedule.every().friday.at("18:00").do(mensagem_planeamento_fim_de_semana)

# ‚ö†Ô∏è PARA TESTE: Descomente a linha abaixo para ele mandar uma mensagem a cada 1 minuto
#schedule.every(1).minutes.do(mensagem_planeamento_fim_de_semana)

# Iniciar o rel√≥gio paralelamente ao Telegram
threading.Thread(target=agendador_em_segundo_plano, daemon=True).start()

# ==========================================
# ROTAS DO TELEGRAM
# ==========================================
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    # NOVO: Grava automaticamente o seu n√∫mero no ficheiro .env
    chat_id = str(message.chat.id)
    set_key(env_path, 'TELEGRAM_CHAT_ID', chat_id)
    os.environ['TELEGRAM_CHAT_ID'] = chat_id
    
    texto = "Fala, ciclista! Sou o teu Coach de MTB com IA. üöµ‚Äç‚ôÇÔ∏è\n\nJ√° gravei o teu contato e a partir de agora vou avisar-te sobre os treinos!\nUsa /semana para o resumo manual."
    bot.reply_to(message, texto)

@bot.message_handler(commands=['semana'])
def analisar_semana(message):
    bot.reply_to(message, "A procurar os teus dados no Strava... ‚è≥")
    dados = obter_resumo_semana()
    if "Erro" in dados:
        bot.reply_to(message, dados)
        return
    prompt = f"Analisa o meu volume de treino desta semana e sugere o pr√≥ximo treino: {dados}"
    resposta_ia = chat_session.send_message(prompt)
    bot.reply_to(message, resposta_ia.text)

@bot.message_handler(func=lambda message: True)
def conversa_livre(message):
    bot.send_chat_action(message.chat.id, 'typing')
    resposta_ia = chat_session.send_message(message.text)
    bot.reply_to(message, resposta_ia.text)

print("ü§ñ Coach Proativo a correr no Telegram! Prima Ctrl+C para parar.")
bot.infinity_polling()